# ADB - Apple Desktop Bus

The ADB-related registers are:

• Keyboard Data register ($C000)
• Modifier Key register ($C025)
• Keyboard Strobe register ($C010)

• Mouse Data register ($C024)

• ADB Command/Data register ($C026)
• ADB Status register ($C027)

C000/C010 are legacy registers to emulate Apple //e. The others are new and ADB-specific.

C000/C010 must be implemented using the underlying ADB logic.

Those registers are all managed by the KeyGloo, a 6502-based Microcontroller that interposes between GS and ADB bus. The GS host has access to about 20 commands it can send to the uC, and it is the uC that manages the actual ADB bus - likely chosen this way because the ADB bus is extremely timing sensitive.

In this emulator, we do not need to go to that level of detail - a real IIgs cannot do anything with ADB except via the uC. The one thing to be mindful about, is that GS software can read from and write to the ADB memory, and does so (address 0x51) in one case to determine if the machine was reset or just powered on. So we should allocate 3K for the ROM and 96 bytes for the RAM inside the keygloo object.


## Interrupts

the ADB Controller can assert 3 interrupts:

* keyboard data available
* mouse data available
* data available (when command/data register contains valid data)

"the keygloo chip can be setup to int whenever keylatch is written to by the uC". Cleared by reading status register followed by read of keyboard latch. If any s/w reads keyboard after status register says int occurred, then int condition will be cleared.
The keylatch, the keymodifiers latch are both valid together until the strobe is cleared.

If mouse has moved or button pushed, returns two bytes data. uC writes x/y values into KEYGLOO which triggers the interrupt. When the second byte is read back by the cPU, the interrupt is cleared. The uC only writes mouse data when registers are empty (after mouse latch X has been read). "Only interrupted at VBL time". unclear how or why.
uC won't do another FDB mouse poll until both bytes have been transferred.

## Layers

There are essentially two layers here.

1. the microcontroller-bus-device layer
1. the GS-microcontroller layer

Generally the system polls. However, a device may signal a Service Request (SR or SRq) to tell the host it has data. All transactions are triggered by the host though.

"ADB Keyboards are prohibited by Cortland from issuing Service Requests". So only the Mouse will ever do this.

### Microcontroller

The ADB microcontroller also implements the keyboard buffer - 16 keystrokes can be queued up / stored. Such that when we seek to refill the keyboard GLU registers, we fetch from that queue.

Mouse Interrupts can occur only during VBL.

So, I think the microcontroller is what is implementing ADB protocol for Mouse and Keyboard, usually, BUT, the CPU can also execute custom ADB commands. YES:

"Scans built-in (internal) keyboard and periodically polls FDB for keyboard and keypad data"
"acts as FDB host for mouse by periodically polling the FDB mouse"
"acts as a transceiver chip for other FDB devices".

https://www.brutaldeluxe.fr/documentation/cortland/v3_10_FDBERS.pdf

Also this has links to a dump of the ROM
https://llx.com/Neil/a2/adb.html

There is a separate KEYGLOO chip "acts as holding register so that data written by uC can be read by system and data written by system can be read by uC". Also this is the chip that generates interrupts.

The keyboard auto-repeat rate is handled by the uC, and delay-before-auto-repeat. There is also "dual speed mode" where arrow key + control is 2x the repeat rate.

"All FDB keyboards and keypads will automatically be handled by the uC". 

Key presses are returned by loading keylatch w/data.  "The key-modifiers latch is updated when a key is pressed and the ASCII value is loaded into the keylatch". The values reflect the state of modifiers when the key was pressed - NOT the current state of the modifiers.

"Bit 5 update" is used to signify modifier latch was changed w/o any other keypresses - only occurs when KYSTB is clear. if only control or shift is pressed and KYSTB is clear, then uC sets Update bit and changes modifiers latch.

Appendix B shows keycodes generated by FDB keyboard.

"undefined codes for FDB keyboards are passed directly through keyboard latch with keypad bit set".

"Polling" by the uC will be simulated by calling the event handler. We could also, potentially, have a frame handler if we needed periodic processing not as a response to an event.



## ADB Command / Data Register - $C026

On a write:

The command (as defined below) is written in these 8 bits. These are uC commands, not directly ADB commands.

On a read:

| Bit | Name | Description |
|-|-|-|
| 7 | Response/status | When this bit is 1, the ADB microcontroller has received a response from an ADB device previously addressed. 0: No response.|
| 6 | Abort/CTRLSTB flush | When this bit is 1, and only this bit in the register is 1, the ADB microcontroller has encountered an error and has reset itself. When this bit is 1 and bit 4 is also 1, the ADB microcontroller should clear the key strobe (bit 7 in the Keyboard Data register at $C000). |
| 5 | Reset key sequence | When this bit is 1, the Control, Command, and Reset keys have been pressed simultaneously. This condition is usually used to initiate a cold start up |
| 4 | Buffer flush key sequence | When this bit is 1, the Control, Command, and Delete keys have been pressed simultaneously. This condition wil result in the ADB microcontroller's flushing al internally buffered commands. |
| 3 | Service request valid | When this bit is 1, a valid service request is pending. The ADB microcontroller will then poll the ADB devices and determine which has initiated the request |
| 2 - 0 | Number of data bytes returned | The number of data bytes to be returned from the command is listed here. |

Subsequent reads will pass data bytes per bits 2-0. 

## Keyboard Modifier Register - $C025

| Bit | Modifier Key Pressed |
|-|-|
| 7 | Command |
| 6 | Option |
| 5 | Modifier Latch updated, but no key pressed |
| 4 | Numeric keypad key |
| 3 | non-modifier key is being held down |
| 2 | Caps Lock |
| 1 | Control |
| 0 | Shift |

Bit 5=1 means these are "live" values.
I think this means if 5=0, then these values are latched and associated with the most recent key press? That is unclear.

These are pretty straightforward.

## Mouse Data register - $C024

| Bit | Description |
|-|-|
| 7 | 1=Mouse button is up, 0=Mouse button is down |
| 6 | Delta sign bit: =1, delta is negative; =0, delta is positive |
| 5-0 | Delta X/Y (with sign bit, up to +/- 31) |

Read register twice in succession; first to get X, second to get Y. If you get out of sync, you will be reading X for Y and vice-versa. Is there a reset for this?

## ADB Status Register - $C027

| Bit | Name | Modifier Key Pressed |
|-|-|-|
| 7 | Mouse Data Reg Full | =1, Mouse Data register at $C024 is full |
| 6 | Mouse int ena/dis | = 1, mouse interrupt is enabled, int generated when mouse register contains valid data |
| 5 | Data register full | =1, command/data register contains valid data |
| 4 | Data interrupt ena/dis | =1, generate interrupt when command/data reg contains valid data |
| 3 | Keybd data register is full | =1, kbd data ($C000) has valid data. =0, kbd register empty. is cleared when kbd data reg is read, or adb status is read |
| 2 | Keybd data register int ena/dis | =1, interrupt thrown when kbd register contains valid data |
| 1 | Mouse X Available | =1, a X-coord data is available; if =0, a Y-coord data is available |
| 0 | Command register full | =1 when command/data register is written to; =0 cmd register empty, cleared when cmd/data register is read |

## Commands / Signals

Command: message sent to a specific device
Signal: broadcast to instruct all devices to perform a function.

Commands:
* Listen (write to device)
* Talk (read from device)
* Device Reset 
* Flush

Signals:
* Attention
* Sync
* Global Reset
* Service Request

## Transaction

Attention / Sync
Address: 4 bits
Cmd: 2 bits: LISTEN
Register: 2 bits
Then, 2 to 8 bytes of data

| Address | Command Code | Register |   |
|-|-|-|-|
| 7 6 5 4 | 3 2 | 1 0 | **Command** |
| x x x x | 0 0 | 0 0 | Send Reset |
| A3 A2 A1 A0 | 0 0 | 0 1 | Flush |
| x x x x | 0 0 | 1 0 | Reserved |
| x x x x | 0 0 | 1 1 | Reserved |
| x x x x | 0 1 | 1 0 | Reserved |
| A3 A2 A1 A0 | 1 0 | r1 r0 | Listen |
| A3 A2 A1 A0 | 1 1 | r1 r0 | Talk |

### Listen (Addressed)

Requests device to store data being transmitted in specified internal register (0-3).
When the host addresses a device to listen, the device receives the next data packet from the host and places it in the appropriate register. (So, 'registers' can be multiple bytes).
If the addressed device detects another command on the bus before it receives any data, the original transaction is immediately considered complete. (This may never happen in practice in an emulator).

### Send Reset (Broadcast)

When a device receives this command, it clears all pending operations and data and inits to power-on state. This will reset ALL devices.

### Flush (Addressed)

Clear all pending commands from the device.

### Attention/Sync

start of every command. Does not need to be emulated.

### Global Reset

If bus held low for 2.8ms, all devices reset. Only initiated by host.

### Service Request

Sent by device, to inform host that a device requires service, for example, when there are data to send to the host.
Following any command packet, a requesting device can signal an SR by holding the bus low. The devices hold this until they have been served.
At that point, the Host polls all devices by sending a Talk Register 0 command beginning with last active device.
Only the device with data to send will respond to this Talk command.
The Mouse does NOT ever use this SR mechanism.

### Device Registers

0-2 are device specific.
Register 3 is Talk: status, and device address handler; Listen: status.

* Keyboard Register 0
  * Bit 15: Key Released
  * Bit 14-8: Keycode 2
  * Bit 7: Key Released
  * Bit 6-0: Keycode 1

* Mouse Register 0
  * Bit 15: Button Pressed
  * Bit 14: Moved Up
  * Bit 13-8: Y move value
  * Bit 7: always 1
  * Bit 6: Moved right
  * Bit 5-0: X move value

* Registers 1 and 2
  * basically unused by keyboard/mouse

* Register 3
  * Bit 15: reserved, must be 0.
  * Bit 14: exceptional event.
  * Bit 13: SR enable
  * Bit 12: Reserved, must be 0.
  * Bit 11-8: Device address.
  * Bit 7-0: Device handler.

* Device Handlers. As Listen Register 3 data,
  * $FF - initiate self-test.
  * $FE - change address field to new address sent in this message.
  * $FD - change address to new address "if activator is pressed"
  * $00 - change address and enable fields to new values sent by host

* Device addresses
  * $02 - Encoded Devices - Keyboard
  * $03 - Relative Devices - Mouse

The keycodes are scancodes, not ASCII:
https://github.com/szymonlopaciuk/stm32-adb2usb/blob/main/src/keymap.h


https://github.com/gblargg/adb-usb/blob/master/keymap.h



So, we need to implement just like the ADB microcontroller. 
1. Receive (and send) messages on an ADB Bus. Have a data structure for a queue of packets.
1. as packets come in, we present them to the ADB Command/Data registers.
1. But, we also process them to some degree, e.g. updating values for $C024, $C025, $C000, etc.

## Commands to Microcontroller

Apparently you send commands to the uC in a format different from the ADB bus itself. That makes sense, the ADB bus timing is very particular.

See Page 13 on in the v3_10_FDBERS document.

# KeyGloo Dev notes

Even though today I only have two devices, and am unsure about ever supporting any other devices (graphics tablets? radio tuners? security keys?)

[ ] Patch in event handling for keyboard.
[ ] Patch in event handling for Mouse.
[ ] test harness  

Apparently the CDA panel is handled by the firmware during VBL interrupts.

Event handling. Put it into this object?
Or, handle it at the device level and decouple the KeyGloo object from: timing, SDL, etc?
Yeah, let's try that.

ok. So, events are sent in this way:
main -> KeyGloo -> ADB_Host -> ADB_Device1, Device2, etc.
then, based on this, the ADB devices should set some information in their registers.
Then, KeyGloo should poll through the ADB Host to get some kind of status. E.g. was a key pressed.
It would do this with a talk() command.
KeyGloo does have special knowledge of Keyboards and Mice.

in the ADB Keyboard device, the keycodes are scan codes, not ascii, even though the GS manual says ascii.
So if we're to maintain this fiction, there is a lot to do.

1. Convert PC/SDL scancode to ADB keyboard scan code.
2. convert ADB Scancode to ascii (in the key latch). or leave it as-is for direct reads from the adb key device.

now, this is ickyish because we already have to call an SDL routine to map from scancode to ascii, in order to take account of international keyboards.
Each international keyboard in a GS is going to have a map. Would this imply we need a unique 

KB register 0 just packs up to two events into one message. 

https://www.brutaldeluxe.fr/documentation/cortland/v3/The%20ADB%20uC%20Tool%20Set%20-%20Peter%20Baum%20-%20Rev%201.1%20-%2019860515.pdf

https://gemini.google.com/app/c600196fa04cec55

OK, the buffer DOES live in the microcontroller, NOT in the keyboard device. Well, the keyboard device seems to be able to hold two keypresses.

```
Example Scan
If you press the 'A' key (ADB code 0x00):

Register 0 result: 0x00FF
00: High byte (Bit 15=0 for Down, Bits 14-8=0x00 for 'A').
FF: Low byte (No second key, idling).

If you release the 'A' key:

Register 0 result: 0x80FF
80: High byte (Bit 15=1 for Up, Bits 14-8=0x00 for 'A').
FF: Low byte (Idling).
```

So while we -could- use both bytes we really probably don't have to. It said "if no data, request ignored". not sure that's right..
if there's data, it goes in high byte, and 0xFF in low byte.
0xFFFF is reset / poweron.

Great convo on this on the slack: https://apple2infinitum.slack.com/archives/CPSGNGE05/p1767030235302959

I am motivated to run this PACMAN GAME on my emulated GS!!

